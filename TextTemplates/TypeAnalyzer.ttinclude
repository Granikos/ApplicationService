<#@ template hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="envdte" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.11.0" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(SolutionDir)\Dependencies\MunirHusseini.TypeAnalyzer.dll" #>
<#@ assembly name="$(SolutionDir)\Dependencies\MunirHusseini.EnvDTE.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio" #>
<#@ import namespace="MunirHusseini.TypeAnalyzer" #>
<#@ import namespace="MunirHusseini.EnvDTE" #>
<#+
private bool _isInitialized = false;
private EnvDTE.DTE _dte;
private ProjectItem _currentProjectItem;
private Project _currentProject;
private Solution _solution;
private List<string> _children = new List<string>();
private IServiceProvider _serviceProvider;
private string _currentDirectory;
private string _fileName;
private string _customTool;

protected string InputAssembly { get; private set; }
protected Dictionary<string, string> Comments { get; private set; }

private string _generatedMemberAttribute = "[System.CodeDom.Compiler.GeneratedCode(\"Nikos.One\", \"1.0.0.0\")]";
protected string GeneratedMemberAttribute { get { return _generatedMemberAttribute; } }

protected string GeneratedFileTag { get { return 
@"// <auto-generated >
// <!-- Input assembly: " + InputAssembly + @" -->
// </auto-generated>";
} }

protected Dictionary<string, string> GetComments(string assembly)
{
	var fileName = Path.Combine(Path.GetDirectoryName(assembly), Path.GetFileNameWithoutExtension(assembly)) + ".xml";
	if(!File.Exists(fileName))
    {
		return new Dictionary<string, string>();
    }

	var doc = XDocument.Load(fileName);
	var d = doc.Root.Element("members").Elements("member").ToDictionary(
		e => (string)e.Attribute("name"),
		e => "/// " + string.Concat(e.Elements().Select(e2 => e2.ToString().Replace("\r\n", "\r\n/// "))) + "\r\n"
		); 

	return d;
}

protected string GetComment(string prefix, params string[] names)
{
	var name = string.Join(".", names.Select(n =>
	{
		var i = n.IndexOf("[");
		return i >= 0 ? n.Substring(0, i) : n;
	}));
	string result;
	return Comments.TryGetValue(prefix + ":" + name, out result) ? result : string.Empty;
}

protected IEnumerable<MunirHusseini.TypeAnalyzer.Type> GetTypes(string projectName, params string[] namespaces)
{
	return GetTypesFrom(projectName, inputAssembly => Analyzer.Analyze(inputAssembly), namespaces);
}

protected IEnumerable<MunirHusseini.TypeAnalyzer.Type> GetTypesFromProject(string projectName, params string[] namespaces)
{
	return GetTypesFrom(projectName, _ => Analyzer.Analyze(projectName, _dte.Solution), namespaces);
}

protected IEnumerable<MunirHusseini.TypeAnalyzer.Type> GetTypesFrom(string projectName, Func<string, Assembly> analyze, params string[] namespaces)
{
	Init();

	var debugParams = new Dictionary<string, object>();
	debugParams.Add("projectName", projectName);

	try
    {
		var inputAssembly = GetProjectOutput(projectName, debugParams);
		var assembly = analyze(inputAssembly);
		
		var namespaces1 = new HashSet<string>(namespaces, StringComparer.InvariantCultureIgnoreCase);
		
		var types = from t in assembly.Types
					where t.IsPublic && (!t.IsAbstract || t.IsInterface) && namespaces1.Contains(t.Namespace)
					select t;
		
		InputAssembly = inputAssembly;
		Comments = GetComments(inputAssembly);

		return types;
    }
	catch(Exception ex)
    {
		OutputError(ex, debugParams);
    }
	
	return new MunirHusseini.TypeAnalyzer.Type[0];
}

private string GetProjectOutput(string projectName, IDictionary<string, object> debugParams)
{
	string inputAssembly;

	if(!projectName.EndsWith(".dll", StringComparison.OrdinalIgnoreCase)  &&
		!projectName.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
    {
		var project = _dte.Solution.GetAllProjects().FirstOrDefault(p => string.Equals(p.Name, projectName));
		debugParams.Add("project.FullName", project.FullName);

		var macroResolver = new MacroResolver(project);		
		inputAssembly = macroResolver.Resolve("TargetPath");
		debugParams.Add("inputAssembly", inputAssembly);
    }
	else
	{
		inputAssembly = projectName;
    }

	return inputAssembly;
}

protected void Init()
{
	if(_isInitialized) return;

	_serviceProvider = (IServiceProvider)this.Host;
	_dte = (EnvDTE.DTE)_serviceProvider.GetService(typeof(EnvDTE.DTE));
	_solution = _dte.Solution;
	_currentProjectItem = _solution.FindProjectItem(this.Host.TemplateFile);
	_currentProject = _currentProjectItem.ContainingProject;
	_currentDirectory = Path.GetDirectoryName(Host.TemplateFile);
	_fileName = Path.GetFileNameWithoutExtension(Host.TemplateFile);

	var currentRelativeFile = _currentProjectItem.FileNames[0].Substring(Path.GetDirectoryName(_solution.FullName).Length + 1);
	_generatedMemberAttribute = "[System.CodeDom.Compiler.GeneratedCode(\"" + currentRelativeFile.Replace("\\", "/") + "\", \"1.0.0.0\")]";

	_isInitialized = true;
}

protected void Cleanup()
{
	var l = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

	foreach (EnvDTE.ProjectItem c in _currentProjectItem.ProjectItems)  
	{
		var file = c.FileNames[0];

		if(!_children.Contains(file))
		{
			c.Remove();
			File.Delete(file);
		}
		else
		{
			l.Add(file);
		}
	}
		
	foreach(var file in _children.Where(c => !l.Contains(c)))
	{
		_currentProjectItem.ProjectItems.AddFromFile(file);
	}

	if(!string.IsNullOrWhiteSpace(_customTool))
	{
		foreach (EnvDTE.ProjectItem c in _currentProjectItem.ProjectItems)  
		{
			c.Properties.Item("CustomTool").Value = _customTool;
		}
	}
}

protected void SetCustomTool(string customTool)
{
	_customTool = customTool;
}

protected void WriteToFile(string outputFileName)
{
	string outputFilePath = Path.Combine(_currentDirectory, outputFileName);
		
	if(File.Exists(outputFilePath))
	{
		File.SetAttributes(outputFilePath, File.GetAttributes(outputFilePath) & ~FileAttributes.ReadOnly); //Remove ReadOnly Property
	}

	using(var fs = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
	using(var w = new StreamWriter(fs))
	{
		var s = this.GenerationEnvironment.ToString();
		s = s.Trim();
		w.Write(s);
	}

	this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);

	_children.Add(outputFilePath);
}

protected MunirHusseini.TypeAnalyzer.Type FindItemType(MunirHusseini.TypeAnalyzer.Property property, out string fullName)
{
	MunirHusseini.TypeAnalyzer.Type itemType = null;
	fullName = null;

	try
	{
		var sb = new StringBuilder();
		var ei = property.Type.EnumerableInfo;

		while(ei != null)
		{
			itemType = ei.ItemType;
			sb.Append("[]");
			ei = ei.NestedEnumerable;
		}

		if(property.Type.IsArray && sb.Length / 2 == 1 && (itemType.IsPrimitive) || itemType.FullName.StartsWith("System."))
		{
			return null;
		}

		fullName = itemType.FullName + sb.ToString();
    }
	catch(Exception ex)
    {
		OutputError(ex, null);
    }

	return itemType;
}

protected void OutputError(Exception ex, IDictionary<string, object> debugParams)
{
	Init();
	var sb = new StringBuilder();

	sb.AppendLine("=========== ERROR ");

	if(debugParams != null && debugParams.Any())
    {
		foreach(var kvp in debugParams)
		{
			sb.AppendLine("" + kvp.Key + ": " + kvp.Value.ToString());
		}
    }

	while(ex != null)
    {
		sb.AppendLine("------------------------");
		sb.AppendLine("msg  : " + ex.Message.Replace(Environment.NewLine, Environment.NewLine + ""));
		sb.AppendLine("trace: " + ex.StackTrace.Replace(Environment.NewLine, Environment.NewLine + ""));

		ex = ex.InnerException;
    }

	sb.AppendLine("============================");

	Output(sb.ToString());
}

protected void Output(string msg)
{
	Write("// " + msg.Replace("\n", "\n// " + "\r\n"));

	// Get the output window
	var outputWindow = _serviceProvider.GetService(typeof(SVsOutputWindow)) as IVsOutputWindow;
 
	// Ensure that the desired pane is visible
	var paneGuid = Microsoft.VisualStudio.VSConstants.OutputWindowPaneGuid.GeneralPane_guid;
	IVsOutputWindowPane pane;
	outputWindow.CreatePane(paneGuid, "General", 1, 0);
	outputWindow.GetPane(paneGuid, out pane);
 
	// Output the message
	pane.OutputString(msg);
	pane.OutputString(Environment.NewLine);
}

protected bool Inherits(MunirHusseini.TypeAnalyzer.Type type, string fullName)
{
	if(type.EnumerableInfo != null && 
		type.EnumerableInfo.ItemType != null && 
		Inherits(type.EnumerableInfo.ItemType, fullName))
    {
		return true;
    }

	while(type != null)
    {
		if(type.FullName == fullName) 
		{
			return true;
        }

		type = type.BaseType;
    }

	return false;
}
#>